---
title: Recomendações de desempenho para o Unity
description: Dicas específicas do Unity para aprimorar o desempenho com aplicativos de realidade misturada.
author: hferrone
ms.author: v-hferrone
ms.date: 03/26/2019
ms.topic: article
keywords: gráficos, cpu, gpu, renderização, coleta de lixo, hololens
ms.localizationpriority: high
ms.openlocfilehash: 2c5a459f673889dd4c52043f9b9df6a3fe43a93a
ms.sourcegitcommit: 09599b4034be825e4536eeb9566968afd021d5f3
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/03/2020
ms.locfileid: "91695296"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="008f1-104">Recomendações de desempenho para o Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="008f1-105">Este artigo se baseia na discussão descrita em [Recomendações de desempenho para realidade misturada](../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md), mas se concentra em aprendizados específicos do ambiente do mecanismo do Unity.</span><span class="sxs-lookup"><span data-stu-id="008f1-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

## <a name="use-recommended-unity-project-settings"></a><span data-ttu-id="008f1-106">Usar configurações de projeto recomendadas do Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-106">Use recommended Unity project settings</span></span>

<span data-ttu-id="008f1-107">A primeira etapa mais importante ao otimizar o desempenho de aplicativos de realidade misturada no Unity é verificar se você está usando as [configurações de ambiente recomendadas para o Unity](recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="008f1-107">The most important first step when optimizing performance of mixed reality apps in Unity is to be sure you are using the [recommended environment settings for Unity](recommended-settings-for-unity.md).</span></span> <span data-ttu-id="008f1-108">Esse artigo traz um conteúdo com algumas das configurações de cena mais importantes para a criação de aplicativos do Mixed Reality de alto desempenho.</span><span class="sxs-lookup"><span data-stu-id="008f1-108">That article contains content with some of the most important scene configurations for building performant Mixed Reality apps.</span></span> <span data-ttu-id="008f1-109">Algumas dessas configurações recomendadas também são realçadas abaixo.</span><span class="sxs-lookup"><span data-stu-id="008f1-109">Some of these recommended settings are highlighted below, as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="008f1-110">Como criar um perfil com o Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-110">How to profile with Unity</span></span>

<span data-ttu-id="008f1-111">O Unity fornece o **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** interno, que é um ótimo recurso para reunir informações de desempenho úteis para seu aplicativo específico.</span><span class="sxs-lookup"><span data-stu-id="008f1-111">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in, which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="008f1-112">Embora seja possível executar o criador de perfil no editor, essas métricas não representam o ambiente de runtime verdadeiro e, portanto, os resultados dessa tarefa devem ser usados com cautela.</span><span class="sxs-lookup"><span data-stu-id="008f1-112">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="008f1-113">É recomendável criar o perfil do aplicativo remotamente durante a execução no dispositivo para obter insights mais precisos e práticos.</span><span class="sxs-lookup"><span data-stu-id="008f1-113">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="008f1-114">Além disso, o [Depurador de Quadros](https://docs.unity3d.com/Manual/FrameDebugger.html) do Unity também é uma ferramenta de insights muito avançada a ser utilizada.</span><span class="sxs-lookup"><span data-stu-id="008f1-114">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="008f1-115">O Unity fornece uma excelente documentação para:</span><span class="sxs-lookup"><span data-stu-id="008f1-115">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="008f1-116">Como conectar o [Unity Profiler aos aplicativos UWP remotamente](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="008f1-116">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="008f1-117">Como [diagnosticar problemas de desempenho com o Unity Profiler de maneira eficaz](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="008f1-117">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="008f1-118">Com o Unity Profiler conectado e após a adição do criador de perfil de GPU (confira *Adicionar Criador de Perfil* no canto superior direito), é possível ver quanto tempo está sendo gasto na CPU e na GPU, respectivamente, no meio do criador de perfil.</span><span class="sxs-lookup"><span data-stu-id="008f1-118">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="008f1-119">Isso permite que o desenvolvedor obtenha uma aproximação rápida caso o aplicativo esteja limitado pela CPU ou pela GPU.</span><span class="sxs-lookup"><span data-stu-id="008f1-119">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![CPU vs GPU do Unity](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="008f1-121">Recomendações de desempenho da CPU</span><span class="sxs-lookup"><span data-stu-id="008f1-121">CPU performance recommendations</span></span>

<span data-ttu-id="008f1-122">O conteúdo abaixo aborda mais práticas de desempenho aprofundadas, especialmente direcionadas ao desenvolvimento em C# e Unity.</span><span class="sxs-lookup"><span data-stu-id="008f1-122">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="008f1-123">Referências de cache</span><span class="sxs-lookup"><span data-stu-id="008f1-123">Cache references</span></span>

<span data-ttu-id="008f1-124">É uma melhor prática armazenar em cache as referências a todos os componentes relevantes e GameObjects na inicialização.</span><span class="sxs-lookup"><span data-stu-id="008f1-124">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="008f1-125">Isso porque as chamadas de função repetitivas como *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* são significativamente mais caras em relação ao custo de memória necessário para armazenar um ponteiro.</span><span class="sxs-lookup"><span data-stu-id="008f1-125">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="008f1-126">Isso também se aplica ao [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html) usado com muita frequência.</span><span class="sxs-lookup"><span data-stu-id="008f1-126">This also applies to to the very regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="008f1-127">Na verdade, o *Camera.main* usa apenas *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* abaixo dele, que pesquisa com alto custo o grafo de cena em busca de um objeto da câmera com a marca *"MainCamera"* .</span><span class="sxs-lookup"><span data-stu-id="008f1-127">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath, which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="008f1-128">Evitar GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="008f1-128">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="008f1-129">Ao usar *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , há várias sobrecargas diferentes.</span><span class="sxs-lookup"><span data-stu-id="008f1-129">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , there are a handful of different overloads.</span></span> <span data-ttu-id="008f1-130">É importante sempre usar as implementações baseadas em tipo e nunca a sobrecarga de pesquisa baseada em cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="008f1-130">It is important to always use the Type-based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="008f1-131">A pesquisa por cadeia de caracteres na cena é significativamente mais cara do que a pesquisa por tipo.</span><span class="sxs-lookup"><span data-stu-id="008f1-131">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="008f1-132">(Adequado) Component GetComponent(Type type)</span><span class="sxs-lookup"><span data-stu-id="008f1-132">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="008f1-133">(Adequado) T GetComponent\<T>()</span><span class="sxs-lookup"><span data-stu-id="008f1-133">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="008f1-134">(Inadequado) Component GetComponent(string)></span><span class="sxs-lookup"><span data-stu-id="008f1-134">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="008f1-135">Evitar operações caras</span><span class="sxs-lookup"><span data-stu-id="008f1-135">Avoid expensive operations</span></span>

1) <span data-ttu-id="008f1-136">**Evite o uso do [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="008f1-136">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="008f1-137">Embora o LINQ possa ser muito limpo e de fácil leitura e escrita, em geral, ele exige muito mais computação e, particularmente, mais alocação de memória do que a escrita manual do algoritmo.</span><span class="sxs-lookup"><span data-stu-id="008f1-137">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="008f1-138">**APIs comuns do Unity**</span><span class="sxs-lookup"><span data-stu-id="008f1-138">**Common Unity APIs**</span></span>

    <span data-ttu-id="008f1-139">Algumas APIs do Unity, embora úteis, podem ser muito caras de serem executadas.</span><span class="sxs-lookup"><span data-stu-id="008f1-139">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="008f1-140">A maioria deles envolve a pesquisa de todo o grafo de cena em busca de alguma lista correspondente de GameObjects.</span><span class="sxs-lookup"><span data-stu-id="008f1-140">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="008f1-141">Em geral, essas operações podem ser evitadas por meio do cache de referências ou da implementação de um componente de gerenciador para os GameObjects em questão, a fim de acompanhar as referências em runtime.</span><span class="sxs-lookup"><span data-stu-id="008f1-141">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

    ```csharp
        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()
    ```

>[!NOTE]
> <span data-ttu-id="008f1-142">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* e *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* devem ser eliminados a qualquer custo.</span><span class="sxs-lookup"><span data-stu-id="008f1-142">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="008f1-143">Essas funções podem estar em uma ordem 1.000 vezes mais lenta do que as chamadas de função diretas.</span><span class="sxs-lookup"><span data-stu-id="008f1-143">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="008f1-144">**Cuidado com a conversão boxing**</span><span class="sxs-lookup"><span data-stu-id="008f1-144">**Beware of boxing**</span></span>

    <span data-ttu-id="008f1-145">A [conversão boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) é um conceito fundamental do runtime e da linguagem C#.</span><span class="sxs-lookup"><span data-stu-id="008f1-145">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="008f1-146">É o processo de encapsular variáveis de tipo de valor, como char, int, bool etc., em variáveis de tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="008f1-146">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="008f1-147">Quando é feita a conversão boxing de uma variável de tipo de valor, ela é encapsulada dentro de um System.Object que é armazenado no heap gerenciado.</span><span class="sxs-lookup"><span data-stu-id="008f1-147">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="008f1-148">Assim, a memória é alocada e, por fim, quando descartada, precisa ser processada pelo coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="008f1-148">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="008f1-149">Essas alocações e essas desalocações geram um custo de desempenho e, em muitos cenários, são desnecessárias ou podem ser substituídas com facilidade por uma alternativa menos cara.</span><span class="sxs-lookup"><span data-stu-id="008f1-149">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="008f1-150">Uma das formas mais comuns de conversão boxing no desenvolvimento é o uso de [tipos de valor que permitem valor nulo](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span><span class="sxs-lookup"><span data-stu-id="008f1-150">One of the most common forms of boxing in development is the use of [nullable value types](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span></span> <span data-ttu-id="008f1-151">É comum querer poder retornar nulo para um tipo de valor em uma função, especialmente quando a operação pode falhar ao tentar obter o valor.</span><span class="sxs-lookup"><span data-stu-id="008f1-151">It is common to want to be able to return null for a value type in a function, especially when the operation may fail trying to get the value.</span></span> <span data-ttu-id="008f1-152">O possível problema dessa abordagem é que a alocação agora ocorre no heap e, consequentemente, precisa ser coletada como lixo mais tarde.</span><span class="sxs-lookup"><span data-stu-id="008f1-152">The potential problem with this approach is that allocation now occurs on the heap and consequently needs to be garbage collected later.</span></span>

    <span data-ttu-id="008f1-153">**Exemplo de conversão boxing em C#**</span><span class="sxs-lookup"><span data-stu-id="008f1-153">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    <span data-ttu-id="008f1-154">**Exemplo de conversão boxing problemática por meio de tipos de valor que permitem valor nulo**</span><span class="sxs-lookup"><span data-stu-id="008f1-154">**Example of problematic boxing via nullable value types**</span></span>

    <span data-ttu-id="008f1-155">Esse código demonstra uma classe de partícula fictícia que pode ser criada em um projeto do Unity.</span><span class="sxs-lookup"><span data-stu-id="008f1-155">This code demonstrates a dummy particle class that one may create in a Unity project.</span></span> <span data-ttu-id="008f1-156">Uma chamada a `TryGetSpeed()` causará a alocação de objeto no heap, que precisará ser coletado como lixo posteriormente.</span><span class="sxs-lookup"><span data-stu-id="008f1-156">A call to `TryGetSpeed()` will cause object allocation on the heap which will need to be garbage collected at a later point in time.</span></span> <span data-ttu-id="008f1-157">Esse exemplo é particularmente problemático, pois pode haver mais de mil ou muito mais partículas em uma cena, cada uma sendo solicitada pela velocidade atual.</span><span class="sxs-lookup"><span data-stu-id="008f1-157">This example is particularly problematic as there may be 1000+ or many more particles in a scene, each being asked for their current speed.</span></span> <span data-ttu-id="008f1-158">Assim, milhares de objetos serão alocados e, consequentemente, desalocados a cada quadro, o que reduzirá muito o desempenho.</span><span class="sxs-lookup"><span data-stu-id="008f1-158">Thus, 1000's of objects would be allocated and consequently de-allocated every frame, which would greatly diminish performance.</span></span> <span data-ttu-id="008f1-159">A reescrita da função para retornar um valor negativo, como -1, a fim de indicar uma falha evitará esse problema e manterá a memória na pilha.</span><span class="sxs-lookup"><span data-stu-id="008f1-159">Re-writing the function to return a negative value such as -1 to indicate a failure would avoid this issue and keep memory on the stack.</span></span>

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="008f1-160">Repetição de caminhos de código</span><span class="sxs-lookup"><span data-stu-id="008f1-160">Repeating code paths</span></span>

<span data-ttu-id="008f1-161">Uma função de retorno de chamada do Unity repetida (ou seja,</span><span class="sxs-lookup"><span data-stu-id="008f1-161">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="008f1-162">Update) executada muitas vezes por segundo e/ou quadro deve ser escrita com muito cuidado.</span><span class="sxs-lookup"><span data-stu-id="008f1-162">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="008f1-163">Qualquer operação cara aqui terá um impacto enorme e consistente sobre o desempenho.</span><span class="sxs-lookup"><span data-stu-id="008f1-163">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="008f1-164">**Funções de retorno de chamada vazio**</span><span class="sxs-lookup"><span data-stu-id="008f1-164">**Empty callback functions**</span></span>

    <span data-ttu-id="008f1-165">Embora possa parecer não ter problema deixar o código abaixo em seu aplicativo, especialmente porque cada script do Unity é inicializado automaticamente com esse bloco de código, esses retornos de chamada vazios podem realmente ficar muito caros.</span><span class="sxs-lookup"><span data-stu-id="008f1-165">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="008f1-166">O Unity opera em um limite de código não gerenciado/gerenciado, entre o código do UnityEngine e o código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="008f1-166">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="008f1-167">A alternância de contexto nessa ponte é bem cara, mesmo que não haja nada a ser executado.</span><span class="sxs-lookup"><span data-stu-id="008f1-167">Context switching over this bridge is fairly expensive, even if there is nothing to execute.</span></span> <span data-ttu-id="008f1-168">Isso se torna especialmente problemático se o aplicativo tem centenas de GameObjects com componentes que tenham retornos de chamada repetitivos e vazios do Unity.</span><span class="sxs-lookup"><span data-stu-id="008f1-168">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="008f1-169">Update() é a manifestação mais comum desse problema de desempenho, mas outros retornos de chamada repetitivos do Unity, como os seguintes, podem ser igualmente tão ruins, se não piores: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage() etc.</span><span class="sxs-lookup"><span data-stu-id="008f1-169">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks, such as the following can be equally as bad, if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="008f1-170">**Operações para favorecer a execução uma vez por quadro**</span><span class="sxs-lookup"><span data-stu-id="008f1-170">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="008f1-171">As APIs do Unity a seguir são operações comuns para muitos aplicativos holográficos.</span><span class="sxs-lookup"><span data-stu-id="008f1-171">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="008f1-172">Embora nem sempre seja possível, os resultados dessas funções podem ser computados com muita frequência, e os resultados são reutilizados no aplicativo para determinado quadro.</span><span class="sxs-lookup"><span data-stu-id="008f1-172">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="008f1-173">a) Em geral, é uma boa prática ter uma classe singleton dedicada ou um serviço para processar o foco Raycast na cena e, em seguida, reutilizar esse resultado em todos os outros componentes de cena, em vez de fazer operações Raycast repetidas e essencialmente idênticas por componente.</span><span class="sxs-lookup"><span data-stu-id="008f1-173">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="008f1-174">É claro que alguns aplicativos podem exigir raycasts de diferentes origens ou em diferentes [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="008f1-174">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>
    
    ```csharp
        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()
    ```

    <span data-ttu-id="008f1-175">b) Evite operações GetComponent() em retornos de chamada repetitivos do Unity, como Update(), com o [cache de referências](#cache-references) em Start() ou Awake()</span><span class="sxs-lookup"><span data-stu-id="008f1-175">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>
    
    ```csharp
        UnityEngine.Object.GetComponent()
    ```

    <span data-ttu-id="008f1-176">c) É uma boa prática criar uma instância de todos os objetos, se possível, na inicialização e usar o [pool de objetos](#object-pooling) para reciclar e reutilizar GameObjects por todo o runtime do aplicativo</span><span class="sxs-lookup"><span data-stu-id="008f1-176">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

    ```csharp
        UnityEngine.Object.Instantiate()
    ```

3) <span data-ttu-id="008f1-177">**Evite interfaces e constructos virtuais**</span><span class="sxs-lookup"><span data-stu-id="008f1-177">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="008f1-178">A invocação de chamadas de função por meio de interfaces em comparação com objetos diretos ou chamada de funções virtuais muitas vezes pode ser muito mais custosa do que a utilização de constructos diretos ou chamadas de função diretas.</span><span class="sxs-lookup"><span data-stu-id="008f1-178">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="008f1-179">Se a interface ou a função virtual for desnecessária, ela deverá ser removida.</span><span class="sxs-lookup"><span data-stu-id="008f1-179">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="008f1-180">No entanto, o impacto no desempenho dessas abordagens geralmente vale a pena se a utilização delas simplifica a colaboração de desenvolvimento, bem como a legibilidade e a manutenção do código.</span><span class="sxs-lookup"><span data-stu-id="008f1-180">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="008f1-181">Em geral, a recomendação é não marcar campos e funções como virtuais, a menos que haja uma expectativa bem definida de que esse membro precise ser substituído.</span><span class="sxs-lookup"><span data-stu-id="008f1-181">Generally, the recommendation is to not mark fields and functions as virtual unless there is a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="008f1-182">É preciso ser especialmente cuidadoso em relação aos caminhos de código de alta frequência que são chamados muitas vezes por quadro ou, até mesmo, uma vez por quadro, como um método `UpdateUI()`.</span><span class="sxs-lookup"><span data-stu-id="008f1-182">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="008f1-183">**Evite transmitir structs por valor**</span><span class="sxs-lookup"><span data-stu-id="008f1-183">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="008f1-184">Ao contrário das classes, os structs são tipos de valor e, quando transmitidos diretamente para uma função, o conteúdo deles é copiado para uma instância recém-criada.</span><span class="sxs-lookup"><span data-stu-id="008f1-184">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="008f1-185">Essa cópia adiciona custo de CPU, bem como memória adicional na pilha.</span><span class="sxs-lookup"><span data-stu-id="008f1-185">This copy adds CPU cost, as well as additional memory on the stack.</span></span> <span data-ttu-id="008f1-186">Para structs pequenos, o efeito é geralmente muito mínimo e, portanto, aceitável.</span><span class="sxs-lookup"><span data-stu-id="008f1-186">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="008f1-187">No entanto, para as funções invocadas repetidamente a cada quadro, bem como as funções que usam structs grandes, se possível, modifique a definição de função para transmiti-la por referência.</span><span class="sxs-lookup"><span data-stu-id="008f1-187">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="008f1-188">Saiba mais aqui</span><span class="sxs-lookup"><span data-stu-id="008f1-188">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="008f1-189">Diversos</span><span class="sxs-lookup"><span data-stu-id="008f1-189">Miscellaneous</span></span>

1) <span data-ttu-id="008f1-190">**Física**</span><span class="sxs-lookup"><span data-stu-id="008f1-190">**Physics**</span></span>

    <span data-ttu-id="008f1-191">r) Em geral, a maneira mais fácil de aprimorar a física é limitar o tempo gasto na física ou no número de iterações por segundo.</span><span class="sxs-lookup"><span data-stu-id="008f1-191">a) Generally, the easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="008f1-192">É claro que isso reduzirá a precisão da simulação.</span><span class="sxs-lookup"><span data-stu-id="008f1-192">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="008f1-193">Confira [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) no Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-193">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="008f1-194">b) Os tipos de colisores no Unity têm características de desempenho amplamente diferentes.</span><span class="sxs-lookup"><span data-stu-id="008f1-194">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="008f1-195">A ordem abaixo lista os colisores com melhor desempenho até os colisores com pior desempenho, da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="008f1-195">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="008f1-196">O mais importante é evitar os colisores de malha, que são consideravelmente mais caros do que os colisores primitivos.</span><span class="sxs-lookup"><span data-stu-id="008f1-196">It is most important to avoid Mesh Colliders, which are substantially more expensive than the primitive colliders.</span></span>

    <span data-ttu-id="008f1-197">Esfera < Cápsula < Caixa <<< Malha (convexa) < Malha (não convexa)</span><span class="sxs-lookup"><span data-stu-id="008f1-197">Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)</span></span>

    <span data-ttu-id="008f1-198">Confira [Melhores práticas de física do Unity](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) para obter mais informações</span><span class="sxs-lookup"><span data-stu-id="008f1-198">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="008f1-199">**Animações**</span><span class="sxs-lookup"><span data-stu-id="008f1-199">**Animations**</span></span>

    <span data-ttu-id="008f1-200">Desabilite as animações ociosas desabilitando o componente Animator (a desabilitação do objeto de jogo não terá o mesmo efeito).</span><span class="sxs-lookup"><span data-stu-id="008f1-200">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="008f1-201">Evite padrões de design em que um animador fica em um loop configurando um valor para o mesmo item.</span><span class="sxs-lookup"><span data-stu-id="008f1-201">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="008f1-202">Há uma sobrecarga considerável nessa técnica, sem nenhum efeito no aplicativo.</span><span class="sxs-lookup"><span data-stu-id="008f1-202">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="008f1-203">Saiba mais aqui.</span><span class="sxs-lookup"><span data-stu-id="008f1-203">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="008f1-204">**Algoritmos complexos**</span><span class="sxs-lookup"><span data-stu-id="008f1-204">**Complex algorithms**</span></span>

    <span data-ttu-id="008f1-205">Se o aplicativo estiver usando algoritmos complexos, como cinemática inversa, localização de caminho etc., procure encontrar uma abordagem mais simples ou ajustar as configurações relevantes para o desempenho dele</span><span class="sxs-lookup"><span data-stu-id="008f1-205">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="008f1-206">Recomendações do desempenho de CPU para GPU</span><span class="sxs-lookup"><span data-stu-id="008f1-206">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="008f1-207">Em geral, o desempenho de CPU para GPU se resume às **chamadas de desenho** enviadas à placa gráfica.</span><span class="sxs-lookup"><span data-stu-id="008f1-207">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="008f1-208">Para aprimorar o desempenho, as chamadas de desenho precisam ser estrategicamente **a) reduzidas** ou **b) reestruturadas** para resultados ideais.</span><span class="sxs-lookup"><span data-stu-id="008f1-208">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="008f1-209">Como as próprias chamadas de desenho fazem uso intensivo de recursos, a redução delas diminuirá o trabalho geral necessário.</span><span class="sxs-lookup"><span data-stu-id="008f1-209">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="008f1-210">Além disso, as alterações de estado entre chamadas de desenho exigem etapas caras de validação e conversão no driver gráfico e, portanto, a reestruturação das chamadas de desenho do aplicativo para limitar as alterações de estado (ou seja,</span><span class="sxs-lookup"><span data-stu-id="008f1-210">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes (i.e</span></span> <span data-ttu-id="008f1-211">materiais diferentes etc.) podem aumentar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="008f1-211">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="008f1-212">O Unity conta com um ótimo artigo que fornece uma visão geral e se aprofunda no envio em lote de chamadas de desenho para a plataforma.</span><span class="sxs-lookup"><span data-stu-id="008f1-212">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="008f1-213">Envio em lote de chamadas de desenho do Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-213">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="008f1-214">Renderização com uma instância de passagem única</span><span class="sxs-lookup"><span data-stu-id="008f1-214">Single pass instanced rendering</span></span>

<span data-ttu-id="008f1-215">A renderização com uma instância de passagem única no Unity permite que as chamadas de desenho para cada olho sejam reduzidas a uma chamada de desenho com instância.</span><span class="sxs-lookup"><span data-stu-id="008f1-215">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="008f1-216">Devido à coerência de cache entre duas chamadas de desenho, também há alguma melhoria de desempenho na GPU.</span><span class="sxs-lookup"><span data-stu-id="008f1-216">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="008f1-217">Como habilitar esse recurso no seu projeto do Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-217">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="008f1-218">Abra **Configurações de XR do Player** (acesse **Editar** > **Configurações do Projeto** > **Player** > **Configurações de XR** )</span><span class="sxs-lookup"><span data-stu-id="008f1-218">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings** )</span></span>
2) <span data-ttu-id="008f1-219">Selecione **Instância de Passagem Única** no menu suspenso **Método de Renderização de Estéreo** (a caixa de seleção **Realidade Virtual Compatível** precisa estar marcada)</span><span class="sxs-lookup"><span data-stu-id="008f1-219">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu ( **Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="008f1-220">Leia os artigos a seguir do Unity para obter detalhes dessa abordagem de renderização.</span><span class="sxs-lookup"><span data-stu-id="008f1-220">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="008f1-221">Como maximizar o desempenho de RA e VR com a renderização avançada de estéreo</span><span class="sxs-lookup"><span data-stu-id="008f1-221">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="008f1-222">Instância de passagem única</span><span class="sxs-lookup"><span data-stu-id="008f1-222">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="008f1-223">Um problema comum na renderização com uma instância de passagem única ocorre se os desenvolvedores já têm sombreadores personalizados existentes não escritos para a criação de instância.</span><span class="sxs-lookup"><span data-stu-id="008f1-223">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="008f1-224">Depois de habilitar esse recurso, os desenvolvedores poderão perceber que alguns GameObjects são renderizados apenas em um olho.</span><span class="sxs-lookup"><span data-stu-id="008f1-224">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="008f1-225">Isso ocorre porque os sombreadores personalizados associados não têm as propriedades apropriadas para a criação de instância.</span><span class="sxs-lookup"><span data-stu-id="008f1-225">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="008f1-226">Confira [Renderização de estéreo de passagem única para o HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) do Unity para saber como resolver esse problema</span><span class="sxs-lookup"><span data-stu-id="008f1-226">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="008f1-227">Envio em lote estático</span><span class="sxs-lookup"><span data-stu-id="008f1-227">Static batching</span></span>

<span data-ttu-id="008f1-228">O Unity pode enviar em lote muitos objetos estáticos para reduzir chamadas de desenho para a GPU.</span><span class="sxs-lookup"><span data-stu-id="008f1-228">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="008f1-229">O envio em lote estático funciona para a maioria dos objetos do [renderizador](https://docs.unity3d.com/ScriptReference/Renderer.html) no Unity que **1) compartilha o material** e **2) é marcada como *Estático*** (selecione um objeto no Unity e clique na caixa de seleção no canto superior direito do inspetor).</span><span class="sxs-lookup"><span data-stu-id="008f1-229">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="008f1-230">Os GameObjects marcados como *Estáticos* não podem ser movidos durante todo o runtime do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="008f1-230">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="008f1-231">Portanto, o envio em lote estático pode ser difícil de ser aproveitado no HoloLens, no qual praticamente todos os objetos precisam ser colocados, movidos, dimensionados etc. Para headsets imersivos, o envio em lote estático pode reduzir drasticamente as chamadas de desenho e, portanto, aprimorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="008f1-231">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="008f1-232">Leia *Envio em lote estático* em [Envio em lote de chamadas de desenho no Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para obter mais detalhes.</span><span class="sxs-lookup"><span data-stu-id="008f1-232">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="008f1-233">Envio em lote dinâmico</span><span class="sxs-lookup"><span data-stu-id="008f1-233">Dynamic batching</span></span>

<span data-ttu-id="008f1-234">Como é problemático marcar objetos como *Estáticos* para o desenvolvimento no HoloLens, o envio em lote dinâmico pode ser uma ótima ferramenta para compensar esse recurso.</span><span class="sxs-lookup"><span data-stu-id="008f1-234">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="008f1-235">É claro que isso também pode ser útil em headsets imersivos.</span><span class="sxs-lookup"><span data-stu-id="008f1-235">Of course, it can also be useful on immersive headsets, as well.</span></span> <span data-ttu-id="008f1-236">No entanto, o envio em lote dinâmico no Unity pode ser difícil de ser habilitado, porque os GameObjects precisam **a) compartilhar o material** e **b) atender a uma lista longa de outros critérios** .</span><span class="sxs-lookup"><span data-stu-id="008f1-236">However, dynamic batching in Unity can be difficult to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria** .</span></span>

<span data-ttu-id="008f1-237">Leia *Envio em lote dinâmico* em [Envio em lote de chamadas de desenho no Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) para obter a lista completa.</span><span class="sxs-lookup"><span data-stu-id="008f1-237">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="008f1-238">Normalmente, os GameObjects se tornam inválidos para serem enviados em lote dinamicamente, porque os dados de malha associados não podem ter mais de 300 vértices.</span><span class="sxs-lookup"><span data-stu-id="008f1-238">Most commonly, GameObjects become invalid to be batched dynamically, because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="008f1-239">Outras técnicas</span><span class="sxs-lookup"><span data-stu-id="008f1-239">Other techniques</span></span>

<span data-ttu-id="008f1-240">O envio em lote só pode ocorrer se vários GameObjects podem compartilhar o material.</span><span class="sxs-lookup"><span data-stu-id="008f1-240">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="008f1-241">Normalmente, isso será bloqueado pela necessidade de os GameObjects terem uma textura exclusiva para o respectivo material.</span><span class="sxs-lookup"><span data-stu-id="008f1-241">Typically, this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="008f1-242">É comum combinar as texturas em uma textura grande, um método conhecido como [atlas de textura](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="008f1-242">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="008f1-243">Além disso, geralmente é preferível combinar malhas em um só GameObject sempre que possível e razoável.</span><span class="sxs-lookup"><span data-stu-id="008f1-243">Furthermore, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="008f1-244">Cada renderizador do Unity terá as chamadas de desenho associadas em vez de enviar uma malha combinada em um renderizador.</span><span class="sxs-lookup"><span data-stu-id="008f1-244">Each Renderer in Unity will have its associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="008f1-245">A modificação das propriedades de Renderer.material em runtime criará uma cópia do material e, portanto, poderá interromper o envio em lote.</span><span class="sxs-lookup"><span data-stu-id="008f1-245">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="008f1-246">Use Renderer.sharedMaterial para modificar as propriedades de material compartilhadas em GameObjects.</span><span class="sxs-lookup"><span data-stu-id="008f1-246">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="008f1-247">Recomendações de desempenho da GPU</span><span class="sxs-lookup"><span data-stu-id="008f1-247">GPU performance recommendations</span></span>

<span data-ttu-id="008f1-248">Saiba mais sobre [como otimizar a renderização de gráficos no Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="008f1-248">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="008f1-249">Otimizar o compartilhamento de buffer de profundidade</span><span class="sxs-lookup"><span data-stu-id="008f1-249">Optimize depth buffer sharing</span></span>

<span data-ttu-id="008f1-250">Geralmente, é recomendável habilitar o **Compartilhamento de buffer de profundidade** nas **Configurações de XR do Player** para otimizar a [estabilidade do holograma](../platform-capabilities-and-apis/Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="008f1-250">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](../platform-capabilities-and-apis/Hologram-stability.md).</span></span> <span data-ttu-id="008f1-251">No entanto, ao habilitar a reprojeção de etapa tardia baseada em profundidade com essa configuração, é recomendável selecionar o **formato de profundidade de 16 bits** em vez do **formato de profundidade de 24 bits** .</span><span class="sxs-lookup"><span data-stu-id="008f1-251">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format** .</span></span> <span data-ttu-id="008f1-252">Os buffers de profundidade de 16 bits reduzem drasticamente a largura de banda (e, portanto, a energia) associada ao tráfego do buffer de profundidade.</span><span class="sxs-lookup"><span data-stu-id="008f1-252">The 16-bit depth buffers will drastically reduce the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="008f1-253">Isso pode ser um grande ganho na redução de energia e na melhoria do desempenho.</span><span class="sxs-lookup"><span data-stu-id="008f1-253">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="008f1-254">No entanto, há dois resultados negativos possíveis com o uso do *formato de profundidade de 16 bits* .</span><span class="sxs-lookup"><span data-stu-id="008f1-254">However, there are two possible negative outcomes by using *16-bit depth format* .</span></span>

<span data-ttu-id="008f1-255">**Luta z**</span><span class="sxs-lookup"><span data-stu-id="008f1-255">**Z-Fighting**</span></span>

<span data-ttu-id="008f1-256">A fidelidade de intervalo de profundidade reduzida possibilita a ocorrência da [luta z](https://en.wikipedia.org/wiki/Z-fighting) mais com 16 bits do que com 24 bits.</span><span class="sxs-lookup"><span data-stu-id="008f1-256">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="008f1-257">Para evitar esses artefatos, modifique os planos de clipes próximos/distantes da [câmera do Unity](https://docs.unity3d.com/Manual/class-Camera.html) para considerar a precisão mais baixa.</span><span class="sxs-lookup"><span data-stu-id="008f1-257">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="008f1-258">Para aplicativos baseados no HoloLens, um plano de recorte distante de 50 m em vez dos 1.000 m padrão do Unity geralmente pode eliminar qualquer luta Z.</span><span class="sxs-lookup"><span data-stu-id="008f1-258">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="008f1-259">**Buffer de estêncil desabilitado**</span><span class="sxs-lookup"><span data-stu-id="008f1-259">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="008f1-260">Quando o Unity cria uma [textura de renderização com profundidade de 16 bits](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), nenhum buffer de estêncil é criado.</span><span class="sxs-lookup"><span data-stu-id="008f1-260">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there is no stencil buffer created.</span></span> <span data-ttu-id="008f1-261">A seleção do formato de profundidade de 24 bits, conforme a documentação do Unity, criará um buffer z de 24 bits, bem como um [buffer de estêncil de 8 bits] (https://docs.unity3d.com/Manual/SL-Stencil.html) (se 32 bits for aplicável em um dispositivo, que geralmente é o caso, como o HoloLens).</span><span class="sxs-lookup"><span data-stu-id="008f1-261">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer, as well as an [8-bit stencil buffer] (https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on a device, which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="008f1-262">Evitar efeitos de tela inteira</span><span class="sxs-lookup"><span data-stu-id="008f1-262">Avoid full-screen effects</span></span>

<span data-ttu-id="008f1-263">As técnicas que operam na tela inteira podem ser bastante custosas, já que a ordem de magnitude é milhões de operações a cada quadro.</span><span class="sxs-lookup"><span data-stu-id="008f1-263">Techniques that operate on the full screen can be quite expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="008f1-264">Portanto, é recomendável evitar [efeitos de pós-processamento](https://docs.unity3d.com/Manual/PostProcessingOverview.html) como suavização, gestos de abrir a mão, entre outros.</span><span class="sxs-lookup"><span data-stu-id="008f1-264">Thus, it is recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="008f1-265">Configurações de iluminação ideais</span><span class="sxs-lookup"><span data-stu-id="008f1-265">Optimal lighting settings</span></span>

<span data-ttu-id="008f1-266">A [Iluminação Global em Tempo Real](https://docs.unity3d.com/Manual/GIIntro.html) do Unity pode fornecer resultados visuais excepcionais, mas envolve cálculos de iluminação bastante custosos.</span><span class="sxs-lookup"><span data-stu-id="008f1-266">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide outstanding visual results but involves quite expensive lighting calculations.</span></span> <span data-ttu-id="008f1-267">É recomendável desabilitar a Iluminação Global em Tempo Real em cada arquivo de cena do Unity por meio de **Janela** > **Renderização** > **Configurações de Iluminação** > Desmarcar **Iluminação Global em Tempo Real** .</span><span class="sxs-lookup"><span data-stu-id="008f1-267">It is recommended to disable Realtime Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination** .</span></span>

<span data-ttu-id="008f1-268">Além disso, é recomendável desabilitar toda a conversão de sombra, pois ela também adiciona passagens de GPU custosas a uma cena do Unity.</span><span class="sxs-lookup"><span data-stu-id="008f1-268">Furthermore, it is recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="008f1-269">As sombras podem ser desabilitadas conforme a luz, mas também podem ser controladas de maneira holística por meio das configurações de Qualidade.</span><span class="sxs-lookup"><span data-stu-id="008f1-269">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="008f1-270">**Editar** > **Configurações do Projeto** e, em seguida, selecione a categoria **Qualidade** > selecione **Baixa Qualidade** para a plataforma UWP.</span><span class="sxs-lookup"><span data-stu-id="008f1-270">**Edit** > **Project Settings** , then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="008f1-271">Também é possível definir apenas a propriedade **Shadows** como **Desabilitar Sombras** .</span><span class="sxs-lookup"><span data-stu-id="008f1-271">One can also just set the **Shadows** property to **Disable Shadows** .</span></span>

<span data-ttu-id="008f1-272">Recomendamos usar a iluminação integrada com seus modelos no Unity.</span><span class="sxs-lookup"><span data-stu-id="008f1-272">It is recommended that you use baked lighting with your models in Unity.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="008f1-273">Reduzir a contagem de polígonos</span><span class="sxs-lookup"><span data-stu-id="008f1-273">Reduce poly count</span></span>

<span data-ttu-id="008f1-274">A contagem de polígonos geralmente é reduzida por meio dos métodos a seguir</span><span class="sxs-lookup"><span data-stu-id="008f1-274">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="008f1-275">Remoção de objetos de uma cena</span><span class="sxs-lookup"><span data-stu-id="008f1-275">Removing objects from a scene</span></span>
2) <span data-ttu-id="008f1-276">Eliminação de ativos, que reduz o número de polígonos para determinada malha</span><span class="sxs-lookup"><span data-stu-id="008f1-276">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="008f1-277">Implementação de um [sistema de LOD (Nível de Detalhe)](https://docs.unity3d.com/Manual/LevelOfDetail.html) no aplicativo que renderiza objetos distantes com a versão de polígono mais baixo da mesma geometria</span><span class="sxs-lookup"><span data-stu-id="008f1-277">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="008f1-278">Noções básicas sobre os sombreadores do Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-278">Understanding shaders in Unity</span></span>

<span data-ttu-id="008f1-279">Uma aproximação fácil para comparar os sombreadores em desempenho é identificar o número médio de operações que cada um executa em runtime.</span><span class="sxs-lookup"><span data-stu-id="008f1-279">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="008f1-280">Isso pode ser feito com facilidade no Unity.</span><span class="sxs-lookup"><span data-stu-id="008f1-280">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="008f1-281">Selecione o ativo do sombreador ou um material e, no canto superior direito da janela do inspetor, selecione o ícone de engrenagem seguido de **"Selecionar Sombreador"**</span><span class="sxs-lookup"><span data-stu-id="008f1-281">Select your shader asset or select a material, then in the top right corner of the inspector window, select the gear icon followed by **"Select Shader"**</span></span>

    ![Selecionar um sombreador no Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="008f1-283">Com o ativo do sombreador selecionado, clique no botão **"Compilar e mostrar código"** na janela do inspetor</span><span class="sxs-lookup"><span data-stu-id="008f1-283">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compilar o código do sombreador no Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="008f1-285">Após a compilação, procure a seção de estatísticas nos resultados com o número de operações diferentes para o vértice e o sombreador de pixel (observação: os sombreadores de pixel costumam ser chamados de sombreadores de fragmento)</span><span class="sxs-lookup"><span data-stu-id="008f1-285">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Operações de sombreador padrão do Unity](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a><span data-ttu-id="008f1-287">Otimizar sombreadores de pixel</span><span class="sxs-lookup"><span data-stu-id="008f1-287">Optimize pixel shaders</span></span>

<span data-ttu-id="008f1-288">Observando os resultados da estatística compilada usando o método acima, em média, o [sombreador de fragmento](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) geralmente executará mais operações do que o [sombreador de vértice](https://en.wikipedia.org/wiki/Shader#Vertex_shaders).</span><span class="sxs-lookup"><span data-stu-id="008f1-288">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), on average.</span></span> <span data-ttu-id="008f1-289">O sombreador de fragmento, também conhecido como sombreador de pixel, é executado por pixel na saída da tela, ao passo que o sombreador de vértice só é executado por vértice de todas as malhas que estão sendo desenhadas na tela.</span><span class="sxs-lookup"><span data-stu-id="008f1-289">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="008f1-290">Portanto, os sombreadores de fragmento têm mais instruções do que os sombreadores de vértice devido a todos os cálculos de iluminação e quase sempre são executados em um conjunto de dados maior.</span><span class="sxs-lookup"><span data-stu-id="008f1-290">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="008f1-291">Por exemplo, se a saída da tela for uma imagem de 2.000 por 2.000, o sombreador de fragmento poderá ser executado 2.000 \* 2.000 = 4.000.000 vezes.</span><span class="sxs-lookup"><span data-stu-id="008f1-291">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="008f1-292">Se a renderização de dois olhos estiver sendo feita, esse número dobrará, pois há duas telas.</span><span class="sxs-lookup"><span data-stu-id="008f1-292">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="008f1-293">Se um aplicativo de realidade misturada tiver várias passagens, efeitos de pós-processamento de tela inteira ou estiver renderizando várias malhas no mesmo pixel, esse número aumentará drasticamente.</span><span class="sxs-lookup"><span data-stu-id="008f1-293">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="008f1-294">Portanto, a redução do número de operações no sombreador de fragmento pode, em geral, proporcionar ganhos de desempenho muito maiores em otimizações no sombreador de vértice.</span><span class="sxs-lookup"><span data-stu-id="008f1-294">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="008f1-295">Alternativas do sombreador padrão do Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-295">Unity Standard shader alternatives</span></span>

<span data-ttu-id="008f1-296">Em vez de usar uma PBR (renderização baseada em física) ou outro sombreador de alta qualidade, examine a utilização de um sombreador mais barato e com melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="008f1-296">Instead of using a physically based rendering (PBR) or another high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="008f1-297">O [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) fornece o [sombreador padrão do MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) que foi otimizado para projetos de realidade misturada.</span><span class="sxs-lookup"><span data-stu-id="008f1-297">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="008f1-298">O Unity também fornece um sombreador apagado, com vértice iluminado, difuso e outras opções de sombreador simplificadas que são significativamente mais rápidas em comparação com o sombreador padrão do Unity.</span><span class="sxs-lookup"><span data-stu-id="008f1-298">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="008f1-299">Confira [Uso e desempenho de sombreadores internos](https://docs.unity3d.com/Manual/shader-Performance.html) para obter informações mais detalhadas.</span><span class="sxs-lookup"><span data-stu-id="008f1-299">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="008f1-300">Pré-carregamento de sombreador</span><span class="sxs-lookup"><span data-stu-id="008f1-300">Shader preloading</span></span>

<span data-ttu-id="008f1-301">Use o *Pré-carregamento de sombreador* e outros truques para otimizar o [tempo de carregamento do sombreador](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="008f1-301">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="008f1-302">Em particular, o pré-carregamento de sombreador significa que você não verá nenhum problema devido à compilação do sombreador em runtime.</span><span class="sxs-lookup"><span data-stu-id="008f1-302">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="008f1-303">Limitar a sobreposição</span><span class="sxs-lookup"><span data-stu-id="008f1-303">Limit overdraw</span></span>

<span data-ttu-id="008f1-304">No Unity, é possível exibir sobreposições para a cena alternando o [**menu do modo de desenho**](https://docs.unity3d.com/Manual/ViewModes.html) no canto superior esquerdo da **Exibição de cena** e selecionando **Sobreposição** .</span><span class="sxs-lookup"><span data-stu-id="008f1-304">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top-left corner of the **Scene view** and selecting **Overdraw** .</span></span>

<span data-ttu-id="008f1-305">Em geral, a sobreposição pode ser atenuada com a remoção de objetos antecipadamente ao envio para a GPU.</span><span class="sxs-lookup"><span data-stu-id="008f1-305">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="008f1-306">O Unity fornece detalhes sobre como implementar a [Remoção de Oclusão](https://docs.unity3d.com/Manual/OcclusionCulling.html) para o mecanismo.</span><span class="sxs-lookup"><span data-stu-id="008f1-306">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="008f1-307">Recomendações de memória</span><span class="sxs-lookup"><span data-stu-id="008f1-307">Memory recommendations</span></span>

<span data-ttu-id="008f1-308">As operações de alocação e desalocação de memória excessiva podem ter efeitos adversos no aplicativo holográfico, resultando em desempenho inconsistente, quadros congelados e outros comportamentos prejudiciais.</span><span class="sxs-lookup"><span data-stu-id="008f1-308">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application, resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="008f1-309">É especialmente importante entender as considerações de memória no desenvolvimento no Unity, pois o gerenciamento de memória é controlado pelo coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="008f1-309">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="008f1-310">Coleta de lixo</span><span class="sxs-lookup"><span data-stu-id="008f1-310">Garbage collection</span></span>

<span data-ttu-id="008f1-311">Os aplicativos holográficos perderão o tempo de computação do processamento para o GC (coletor de lixo) quando o GC for ativado para analisar objetos que não estão mais no escopo durante a execução, e a memória deles precisará ser liberada, de modo que possa ser disponibilizada para reutilização.</span><span class="sxs-lookup"><span data-stu-id="008f1-311">Holographic apps will lose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released, so it can be made available for re-use.</span></span> <span data-ttu-id="008f1-312">As alocações e as desalocações constantes geralmente exigirão que o coletor de lixo seja executado com mais frequência, prejudicando o desempenho e a experiência do usuário.</span><span class="sxs-lookup"><span data-stu-id="008f1-312">Constant allocations and de-allocations will generally require the garbage collector to run more frequently, thus hurting performance and user experience.</span></span>

<span data-ttu-id="008f1-313">O Unity forneceu uma página excelente que explica em detalhes como o coletor de lixo funciona e dicas para escrever um código mais eficiente em relação ao gerenciamento de memória.</span><span class="sxs-lookup"><span data-stu-id="008f1-313">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="008f1-314">Como otimizar a coleta de lixo em jogos do Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-314">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="008f1-315">Uma das práticas mais comuns que leva ao excesso de coleta de lixo não é armazenar em cache referências a componentes e classes no desenvolvimento no Unity.</span><span class="sxs-lookup"><span data-stu-id="008f1-315">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="008f1-316">Todas as referências devem ser capturadas durante Start() ou Awake() e reutilizadas em funções posteriores, como Update() ou LateUpdate().</span><span class="sxs-lookup"><span data-stu-id="008f1-316">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="008f1-317">Outras dicas rápidas:</span><span class="sxs-lookup"><span data-stu-id="008f1-317">Other quick tips:</span></span>
- <span data-ttu-id="008f1-318">Use a classe C# [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder) para criar dinamicamente cadeias de caracteres complexas em runtime</span><span class="sxs-lookup"><span data-stu-id="008f1-318">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="008f1-319">Remova as chamadas a Debug.Log() quando não for mais necessário, pois elas ainda são executadas em todas as versões de build de um aplicativo</span><span class="sxs-lookup"><span data-stu-id="008f1-319">Remove calls to Debug.Log() when no longer needed, as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="008f1-320">Se o aplicativo holográfico geralmente exige muita memória, considere a possibilidade de chamar [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect) durante o carregamento de fases, como ao apresentar uma tela de carregamento ou de transição</span><span class="sxs-lookup"><span data-stu-id="008f1-320">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="008f1-321">Pool de objetos</span><span class="sxs-lookup"><span data-stu-id="008f1-321">Object pooling</span></span>

<span data-ttu-id="008f1-322">O pool de objetos é uma técnica popular para reduzir o custo de alocações e desalocações contínuas de objetos.</span><span class="sxs-lookup"><span data-stu-id="008f1-322">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="008f1-323">Isso é feito pela alocação de um grande pool de objetos idênticos e pela reutilização das instâncias disponíveis inativas desse pool em vez da criação e da destruição constantes de objetos ao longo do tempo.</span><span class="sxs-lookup"><span data-stu-id="008f1-323">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="008f1-324">Os pools de objetos são ótimos para componentes reutilizados que têm um tempo de vida variável durante um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="008f1-324">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="008f1-325">Tutorial de pool de objetos no Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-325">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="008f1-326">Desempenho de inicialização</span><span class="sxs-lookup"><span data-stu-id="008f1-326">Startup performance</span></span>

<span data-ttu-id="008f1-327">Você deve considerar iniciar seu aplicativo com uma cena menor e, em seguida, usar *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* para carregar o restante da cena.</span><span class="sxs-lookup"><span data-stu-id="008f1-327">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="008f1-328">Isso permite que o aplicativo chegue a um estado interativo o mais rápido possível.</span><span class="sxs-lookup"><span data-stu-id="008f1-328">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="008f1-329">Esteja ciente de que pode haver um grande pico de CPU enquanto a nova cena está sendo ativada e que qualquer conteúdo renderizado pode tremer ou apresentar algum problema.</span><span class="sxs-lookup"><span data-stu-id="008f1-329">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="008f1-330">Um modo de resolver isso é definir a propriedade AsyncOperation.allowSceneActivation como "false" na cena que está sendo carregada, aguardar a cena ser carregada, limpar a tela para preto e, em seguida, defini-la novamente como "true" para concluir a ativação da cena.</span><span class="sxs-lookup"><span data-stu-id="008f1-330">One way to work around this is to set the AsyncOperation.allowSceneActivation property to "false" on the scene being loaded, wait for the scene to load, clear the screen to black, and then set it back to "true" to complete the scene activation.</span></span>

<span data-ttu-id="008f1-331">Lembre-se de que, durante o carregamento da cena de inicialização, a tela inicial holográfica será exibida para o usuário.</span><span class="sxs-lookup"><span data-stu-id="008f1-331">Remember that while the startup scene is loading, the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="008f1-332">Veja também</span><span class="sxs-lookup"><span data-stu-id="008f1-332">See also</span></span>
- [<span data-ttu-id="008f1-333">Como otimizar a renderização de gráficos em jogos do Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-333">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="008f1-334">Como otimizar a coleta de lixo em jogos do Unity</span><span class="sxs-lookup"><span data-stu-id="008f1-334">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="008f1-335">[Melhores práticas de física [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="008f1-335">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="008f1-336">[Como otimizar scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="008f1-336">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
